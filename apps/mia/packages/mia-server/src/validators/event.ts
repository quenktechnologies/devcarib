/**
 * AUTOGENERATED - DO NOT EDIT DIRECTLY!
 */ 

import { Event } from '@mia/types/lib/event';
import { textsmall,minLength,date,time,tzoffset,url,textmedium,textlarge,maxLength } from '@devcarib/common/lib/data/validators';
import * as _json from '@quenk/noni/lib/data/jsonx';
import * as _prec from '@quenk/preconditions';
import * as _booleanPrec from '@quenk/preconditions/lib/boolean';
import * as _numberPrec from '@quenk/preconditions/lib/number';
import * as _stringPrec from '@quenk/preconditions/lib/string';
import * as _recordPrec from '@quenk/preconditions/lib/record';
import * as _arrayPrec from '@quenk/preconditions/lib/array';

/**
 * DataType validated.
 * 
 * Used by template generation.
 * @private 
 */
export type DataType = Event;

//@ts-ignore: 6133
const _boolean = _booleanPrec.toBoolean;

//@ts-ignore: 6133
const _number = _numberPrec.toNumber;

//@ts-ignore: 6133
const _string:_prec.Precondition<_json.Value, string> =
_prec.and(_stringPrec.isString, _stringPrec.trim);

//@ts-ignore: 6133
const _complete = _recordPrec.restrict;

//@ts-ignore: 6133
const _partial = _recordPrec.intersect;


/**
 * fieldValidators for Event (AUTOGENERATED).
 */ 
export const fieldValidators: _prec.Preconditions<_json.Value, _json.Value> = {
      'title' : _prec.and(_prec.notNull,       _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textsmall,minLength(3)))
),

      'startDate' : _prec.and(_prec.notNull,       _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(date))
),

      'startTime' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(time))
),

      'tzOffset' : _prec.and(_prec.notNull,       _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(tzoffset))
),

      'endDate' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(date))
),

      'endTime' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(time))
),

      'url' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(url))
),

      'location' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textsmall))
),

      'host' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textmedium))
),

      'description' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textlarge,minLength(3),maxLength(6000)))
),

};

/**
 * partialFieldValidators for Event (AUTOGENERATED).
 */ 
export const partialFieldValidators:_prec.Preconditions<_json.Value, _json.Value> = {
      'title' : _prec.and(_prec.notNull,       _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textsmall,minLength(3)))
),

      'startDate' : _prec.and(_prec.notNull,       _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(date))
),

      'startTime' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(time))
),

      'tzOffset' : _prec.and(_prec.notNull,       _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(tzoffset))
),

      'endDate' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(date))
),

      'endTime' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(time))
),

      'url' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(url))
),

      'location' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textsmall))
),

      'host' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textmedium))
),

      'description' : _prec.optional(      _prec.and(    _string
,
      _prec.every<_json.Value,_json.Value>(textlarge,minLength(3),maxLength(6000)))
),

};

/**
 * validate a value to determine if it satisfies the Event type
 * (AUTOGENERATED).
 */
export const validate: _prec.Precondition<_json.Value, Event> =
 _prec.and(
  _recordPrec.isRecord, 
  _recordPrec.restrict<_json.Value, _json.Value, Event>(fieldValidators)
 );

/**
 * validatePartial is like validate but only tests the fields encountered
 * (AUTOGENERATED).
 */
export const validatePartial: _prec.Precondition<_json.Value, Partial<Event>> =
 _prec.and(
  _recordPrec.isRecord, 
  _recordPrec.intersect<_json.Value, _json.Value, Event>(partialFieldValidators)
 );
